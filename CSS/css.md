# 30 CSS Interview Questions and Answers

# 1. CSS Box Model

The CSS box model defines how each element’s box is composed of **content**, **padding**, **border**, and **margin**. The *content box* is the area for text/images. The *padding box* surrounds the content, then the *border box*, and finally the *margin box*. By default (`box-sizing: content-box`), the `width` and `height` you set apply to the content box, and padding/border are added on top. For example:

```css
.box {
  width: 350px;
  height: 150px;
  padding: 25px;
  border: 5px solid black;
}
```

This box’s content is 350×150px, but its total outer size becomes 410×210px (350 + 25+25 + 5+5 for width, and similarly for height). Margins lie outside the border and affect spacing but don’t increase the box’s own size.

If you use `box-sizing: border-box`, the specified width *includes* padding and border. In that case, a 350px-wide box with 25px padding and 5px border keeps the **outer** width 350px, and the content area shrinks accordingly. This can simplify layout sizing.

# 2. CSS Cascade and Inheritance

CSS stands for “Cascading Style Sheets,” meaning rules cascade from different sources. The browser uses a cascade algorithm considering **origin** (browser/user/author), **importance** (`!important`), **specificity**, and **order** to determine which rule applies. For instance, if two rules with equal specificity apply, the one defined *later* in the stylesheet wins. Inline style attributes have extremely high specificity (effectively weight 1-0-0-0) and override normal rules. `!important` declarations override normal cascade order (author `!important` beats any normal author rule, and even beats user rules).

Some properties are **inherited**: setting a property on an element makes its children use that value unless they override it. For example, if you set `color: blue` on `<body>`, all text inside (unless restyled) will be blue. In contrast, box-layout properties (margin, padding, width, etc.) do *not* inherit by default. In summary, cascade rules (origin, specificity, order) resolve conflicts, while inheritance means some property values propagate from parent to children.

# 3. CSS Specificity

Specificity is how CSS determines which selector “wins” when multiple rules match the same element. Each selector’s specificity can be thought of as a 4-part weight: inline styles (1,0,0,0), IDs (0,1,0,0), classes/attributes/pseudo-classes (0,0,1,0), and element/pseudo-elements (0,0,0,1). A higher-weight selector beats a lower one. For example, a class selector has more weight than a type selector.

```css
h1.main-heading { color: red; } /* specificity 0,1,1,0 */
h1            { color: blue; } /* specificity 0,0,0,1 */
```

The `<h1 class="main-heading">` will be **red**, because `.main-heading` (class) has higher specificity than the plain `h1` selector. If two selectors tie in specificity and importance, the one declared later wins. Inline `style=""` (treated as 1-0-0-0) beats any external rule, and the only way to override an inline style is with an even more specific rule or an `!important`.

# 4. CSS Selectors and Combinators

CSS selectors define **which elements** to style. Fundamental selectors include type selectors (`div`), class (`.button`), ID (`#header`), and the universal selector (`*`). Attribute selectors (e.g. `input[type="text"]`) target elements by attributes. Combinators refine relationships:

* **Descendant** (`a b`) selects all `<b>` inside any `<a>`.
* **Child** (`a > b`) selects `<b>` whose parent is `<a>`.
* **Adjacent sibling** (`a + b`) selects `<b>` immediately after `<a>`.
* **General sibling** (`a ~ b`) selects any `<b>` after `<a>` on the same level.

For example: `.nav > ul li` means “an `<li>` inside a `<ul>` that is a child of `.nav`”. Selectors can be grouped with commas to apply the same rule. The CSS Selectors Level 4 spec provides many (60+) selectors and combinators (space, `>`, `+`, `~`, `||`) for targeting elements by type, attributes, state, or DOM position.

# 5. Pseudo-Classes vs Pseudo-Elements

Pseudo-classes and pseudo-elements look similar but serve different purposes. A **pseudo-class** (single colon, e.g. `:hover`, `:first-child`) selects elements in a special *state* or position. For example, `a:hover` styles links when the mouse is over them, and `li:first-child` matches an `<li>` if it’s the first child of its parent.

A **pseudo-element** (double colon, e.g. `::before`, `::after`, `::first-line`) represents a virtual subpart of an element or a “new” element generated by CSS. For example, `p::first-line` styles only the first line of a paragraph, and `div::before` inserts content before the `<div>`’s actual content. Pseudo-elements behave like added elements in the DOM. For instance, `#box::before { content: ""; }` creates a new box inside `#box`. In short, pseudo-classes match existing elements by state, while pseudo-elements create or target subpieces of elements.

# 6. CSS Measurement Units (Absolute vs Relative)

CSS offers **absolute** units (px, pt, cm, in, etc.) and **relative** units. *Absolute units* like `px` (pixels) are device-specific but common in web design. For example, `1in` is defined as 96px and `1pt` is 1/72in. Absolute units are rarely used except `px`, which corresponds to CSS pixels.

*Relative units* adjust to context:

* `em` is relative to the current element’s font size (or parent’s, for some properties).
* `rem` is relative to the root (`<html>`) font size (e.g. 16px by default).
* `%` is usually relative to the parent element’s corresponding dimension.
* Viewport units like `vw`/`vh` are relative to viewport width/height (1vw is 1% of viewport width).

For example, if `html { font-size: 20px; }`, then `1rem` = 20px; `2rem` = 40px. If a parent is 400px wide, then `width: 50%` on a child makes it 200px. Using relative units like `rem` or `%` helps create scalable layouts. The MDN reference notes that absolute units (e.g. `cm`, `mm`, `pt`) exist but are fixed, whereas relative units (like `%`, `em`, `rem`, `vw/vh`) adapt to context.

# 7. CSS Flexbox Fundamentals

CSS Flexbox provides a one-dimensional layout model for arranging items in a container. To use it, set `display: flex` (or `inline-flex`) on a container. This makes its children **flex items**. Key container properties include:

* `flex-direction` (row or column) to set the main axis.
* `flex-wrap` (`nowrap`, `wrap`, `wrap-reverse`) to allow items to wrap onto multiple lines.
* `justify-content` to align items along the main axis.
* `align-items` to align items along the cross axis (perpendicular to the main axis).
* `align-content` to align multiple lines of items when wrapping.

Flex items themselves have properties:

* `flex-grow`: how much a flex item will grow to fill space.
* `flex-shrink`: how it shrinks when space is tight.
* `flex-basis`: the initial main size before free space distribution.
* The shorthand `flex: <grow> <shrink> <basis>` sets all three at once.

For example:

```css
.container {
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  justify-content: space-between;
  align-items: center;
}
.item {
  flex: 1 1 200px; /* grow=1, shrink=1, basis=200px */
}
```

This creates a flex container whose items are evenly spaced horizontally and centered vertically. The CSS-Tricks guide notes that Flexbox is excellent for small to medium layout components.

# 8. Centering with Flexbox

Flexbox makes centering straightforward. Using `justify-content` and `align-items` on the container will center its children. Along the main axis (e.g. horizontal in a row), use `justify-content: center`. Along the cross-axis (vertical in a row), use `align-items: center`. For example:

```css
.container {
  display: flex;
  height: 200px;
  justify-content: center; /* center horizontally */
  align-items: center;     /* center vertically */
}
```

Any single child inside `.container` will be perfectly centered. MDN demonstrates this: setting both properties to `center` horizontally and vertically centers the content. If you have multiple items and a single line, `justify-content: center` packs them together in the middle, whereas `align-items: center` centers them across the container’s cross-axis.

# 9. Flex Item Properties (`flex-grow`, `flex-shrink`, `flex-basis`)

Each flex item can expand or shrink within the flex container. The key properties are:

* `flex-grow`: a unitless factor of how much free space the item should take relative to its siblings. A value of `1` means “take equally share of leftover space”.
* `flex-shrink`: factor controlling how the item shrinks if the container is too small.
* `flex-basis`: the initial size of the item before distributing space.

For example:

```css
.box1 { flex: 1 1 100px; }
.box2 { flex: 2 1 100px; }
```

If the container has extra space, `.box2` will grow twice as much as `.box1`. If not enough space, both will shrink proportionally. The shorthand `flex: <grow> <shrink> <basis>` sets all three. Note: `flex: 1` is shorthand for `flex: 1 1 0%`, meaning it can grow and shrink but starts at 0 width. Conversely, `flex: none` equates to `flex: 0 0 auto` (no grow/shrink, size by content). The MDN docs explain that `flex: auto` expands to `1 1 auto` (sized by width/height but still flexible).

# 10. CSS Grid Layout Basics

CSS Grid is a two-dimensional layout system for placing items in rows and columns. You enable it by setting `display: grid` (or `inline-grid`) on a container. Unlike Flexbox (one-dimensional), Grid lets you define explicit **grid tracks**. For example:

```css
.container {
  display: grid;
  grid-template-columns: 200px 1fr 2fr; /* three columns */
  grid-template-rows: 100px auto;      /* two rows */
  gap: 10px;
}
```

Here, the grid has three columns (200px wide, 1fr, and 2fr) and two rows. The `fr` unit distributes remaining space; for instance, `2fr` is twice the size of `1fr`. The MDN guide notes Grid excels for larger page layouts, whereas Flexbox is ideal for smaller components. Grid also allows overlapping and precise placement using named lines or `grid-row`, `grid-column` on items. In summary, use Flexbox when aligning items in one dimension (row or column), and use Grid when you need a full two-dimensional grid layout.

# 11. CSS Grid Functions: `repeat()`, `minmax()`, `fr`

CSS Grid includes helpful functions:

* `repeat(n, <track>)` repeats a column/row pattern n times. E.g. `grid-template-columns: repeat(3, 1fr);` creates three equal 1fr columns.
* `minmax(min, max)` sets a track’s size to shrink no less than `min` or grow no more than `max`. For example, `grid-auto-rows: minmax(100px, auto);` means each row is at least 100px tall but can grow to fit content.
* The `fr` unit stands for a “fraction” of available space: `1fr` is one share, so if there is extra space, each `fr` unit divides it.

Example code from MDN:

```css
.wrapper {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 10px;
  grid-auto-rows: minmax(100px, auto);
}
```

This makes a 3-column grid where columns share space equally and each row is at least 100px tall. These functions greatly simplify defining responsive grid layouts.

# 12. CSS Positioning: `static`, `relative`, `absolute`, `fixed`

CSS `position` controls how an element is placed. The default `position: static` means the element follows normal document flow (top/left/etc offsets do nothing). With `position: relative`, the element remains in flow but you can offset it via `top/left`; the space for the element in the layout is still reserved.

With `position: absolute`, the element is *removed* from normal flow (no space is reserved) and positioned relative to its nearest ancestor that has position other than static (or the page if none). For example:

```css
.parent { position: relative; }
.child  { position: absolute; top: 10px; left: 20px; }
```

Here `.child` sits 10px from the top of `.parent` and 20px from its left edge.

`position: fixed` is similar to absolute but the element is fixed relative to the viewport (it stays in place even when scrolling). A fixed header or footer uses this. Note: if an ancestor has certain transforms or filters, it can change the containing block for fixed items.

# 13. CSS Sticky Positioning

`position: sticky` is like a hybrid of `relative` and `fixed`. An element with `position: sticky` behaves as relative **until** the page is scrolled to a defined threshold, then it “sticks” (becomes fixed) to that position. Typically you use it with `top: 0`, for example:

```css
.header {
  position: sticky;
  top: 0;
}
```

As the user scrolls, the `.header` will stick to the top of its container (often the viewport) once it reaches that point. Sticky elements stick within their nearest scrolling ancestor. In other words, until you scroll past it, the element is in normal flow; then it stays fixed until its parent scrolls out of view. This is useful for table headers or section titles that should remain visible.

# 14. CSS Transitions

CSS transitions allow property changes to animate smoothly over time. You define a transition on an element (typically on hover or a class change) like:

```css
.box {
  transition: background-color 0.3s ease;
}
.box:hover {
  background-color: blue;
}
```

This causes the background color to fade to blue over 0.3 seconds when hovered. Transitions only animate changes between two states and must be triggered by some change (hover, class toggle, etc.). MDN notes that transitions control animation *speed* when CSS properties change, easing the change with timing functions. Transition shorthand is `transition: <property> <duration> <timing-function> <delay>`.

# 15. CSS Animations (`@keyframes`)

CSS animations are more powerful than transitions. Using `@keyframes`, you can define multiple stages of an animation and loop it. For example:

```css
@keyframes fade-in {
  from { opacity: 0; }
  to   { opacity: 1; }
}
.box {
  animation: fade-in 2s ease-in-out 1s 3 alternate;
}
```

This fades `.box` in from opacity 0 to 1, over 2s with a 1s delay, repeating 3 times, alternating direction each cycle. Animations run independently of user interaction (unless you pause them). The MDN documentation explains that keyframes give **more control** than transitions because you can specify intermediate steps. Transitions only interpolate between a start and end, whereas `@keyframes` can have complex sequences, delays, iteration counts, and direction. In short, use CSS transitions for simple state changes (hover, focus) and use keyframe animations for multi-step or repeating animations.

# 16. z-index

The `z-index` property sets an element’s stack order (which element is on top of others) when elements overlap. A higher `z-index` means the element is closer to the user/viewer. Only positioned elements (those with `position` other than `static`) can have `z-index` applied. For example, if two absolutely positioned `<div>`s overlap, the one with `z-index: 10` will cover one with `z-index: 5`. Without a specified `z-index`, elements stack by source order.

However, `z-index` only works within a **stacking context**. If elements are in different stacking contexts, their `z-index` is only comparable within their own context. For example, a child with `z-index: 999` inside one stacking context cannot escape out to cover another unrelated context with `z-index: 1`. Within one stacking context, normal stacking rules (position order or z-index value) apply.

# 17. Stacking Context

A stacking context is a self-contained stacking order. By default, the root element forms the first stacking context. New stacking contexts are formed by elements with certain properties, such as any element with `position` other than static and a `z-index` value (other than `auto`), or elements with `opacity < 1`, `transform`, `filter`, `will-change`, `isolation: isolate`, and a few others. Each stacking context arranges its children by z-index internally.

This means: if an element establishes a new context, its children will stack inside that context. For instance, a `position: relative; z-index: 0;` on a parent creates a new context. No matter how high you set z-index on its children, they cannot escape to overlap elements outside that context. The CSS spec states a property value from the highest-precedence origin wins, but stacking contexts group elements before that consideration.

In practice, common stacking-context triggers include `position: relative/absolute` with `z-index`, `position: fixed/sticky`, `opacity: 0.5`, `transform: rotate(...)`, `filter: blur(...)`, or any flex/grid child with z-index. The key is that each such element and its children are isolated. Within each context, a higher `z-index` wins. Understanding this prevents confusion (e.g. a child with high z-index not popping outside its parent container).

# 18. Accessibility – Focus Outlines

For keyboard navigation, it’s critical to indicate focus. By default browsers draw an outline on focused elements (especially links/buttons) when tabbed to. One common pitfall is removing this (`outline: none`) for custom styling, which hurts accessibility. The WCAG advises **never remove focus indicators without a suitable replacement**. Always ensure a visible focus style (outline or background) on interactive elements (links, buttons, form fields). For example:

```css
button:focus {
  outline: 3px solid Highlight; /* or use a custom style */
}
```

This aids sighted keyboard users. MDN explicitly warns that removing the focus outline without a proper replacement violates accessibility SC 1.4.11.

# 19. Accessibility – `prefers-` Media Queries (Reduced Motion, Dark Mode)

Modern CSS can adapt to user preferences. Two important media features are:

* `prefers-reduced-motion`: detect if the user has requested minimal motion (in OS settings). Use it to disable or simplify animations and transitions for those users. For example:

  ```css
  @media (prefers-reduced-motion: reduce) {
    .animated { transition: none; animation: none; }
  }
  ```
* `prefers-color-scheme`: detect light vs dark mode preference. You can swap colors accordingly, e.g.

  ```css
  @media (prefers-color-scheme: dark) {
    body { background: #222; color: #eee; }
  }
  ```

MDN notes that `prefers-reduced-motion` and `prefers-contrast` allow CSS to respect these preferences. Using `@media (prefers-contrast: more)` or `:more`, you can also adapt to high-contrast needs. By using these media queries, your site honors accessibility settings (motion, color, contrast) that users have chosen at the OS level.

# 20. Performance – Animate Transform & Opacity Only

CSS changes can trigger **reflows** and **repaints**. Some properties (like `width`, `height`, `top`, `left`, `margin`, etc.) affect layout and will cause the browser to recalculate layout (expensive). When animating or transitioning, avoid these. Instead animate `transform` and `opacity`, which are handled by the compositor and are much cheaper. For example, to move or scale elements, use `transform: translateX()` rather than changing `left`. Similarly, fade an element by animating `opacity` not by manipulating background-color if possible. The MDN performance guide specifically warns that animating layout-affecting properties triggers reflow; whereas using `transform` or `opacity` does not. This leads to smoother animations and less layout thrashing.

# 21. Performance – Selectors, Containment, Will-Change

Other CSS performance tips:

* **Simple selectors:** Complex selectors (deep descendant chains, universal selectors, etc.) take longer to match. Keep selectors as simple as practical. For example, avoid `div ul li a` chains; using classes or direct selectors is faster.
* **CSS Containment:** The `contain` property (e.g. `contain: layout paint;`) can isolate elements so that style/layout changes in that subtree don’t affect outside. This limits how far the browser must recalculate or repaint.
* **Will-Change:** Use `will-change: transform, opacity` on elements you plan to animate to hint the browser to optimize them ahead of time. However, `will-change` should be used sparingly (only on a few elements) because it forces the browser to create layers.

In general, minimizing reflows/repaints means batching DOM updates, using transforms for animations, and breaking large CSS (e.g. using lazy-loading or splitting) so the browser has less to parse on initial load. Using modern properties like `content-visibility: auto` (see next) also helps performance.

# 22. CSS Containment & Content-Visibility

CSS offers new properties for optimization. The `contain` property tells the browser to limit the scope of layout, style, or paint. For example, `contain: layout paint;` on a component ensures it’s self-contained so changes inside it won’t force recalculations elsewhere. This can significantly improve performance in large apps.

Even more powerful is `content-visibility: auto;`. When applied to a large element (like a long list), the browser can skip rendering its contents until it’s needed (e.g. scrolled into view). The MDN module on content-visibility explains that with this setting, the UA may skip an element’s rendering (including layout/paint) until necessary. In practice, `content-visibility: auto` with `contain-intrinsic-size` can dramatically speed up initial paint by only processing above-the-fold content.

# 23. CSS Margin Collapsing

Vertical margins between block-level elements can collapse. This means if two elements with margins touch, the larger margin wins instead of adding them. For example:

```css
p { margin: 20px 0; }
p + p { margin-top: 30px; }
```

The margin between those `<p>`s will be 30px, *not* 50px. Likewise, if a parent and child both have top margins, the margins collapse to the larger one. MDN notes that *“top and bottom margins are sometimes collapsed into a single margin that is equal to the larger”*. This collapsing occurs for touching block elements (and empty block’s margins with its parent). It’s important to remember so layouts don’t end up with unexpected spacing (adding padding or borders can prevent collapse).

# 24. `justify-content`: space-between, space-around, space-evenly

When using Flexbox or Grid, `justify-content` controls how extra space is distributed on the main axis. The values with “space” are common:

* `space-between`: Items are evenly distributed, with the first item at the start and the last at the end. All gaps between adjacent items are equal.
* `space-around`: Items are evenly distributed with equal space around them. This results in half-sized space on the ends. (Each item has equal left/right margin, so end gaps are half.)
* `space-evenly`: Items and the edges all get equal spacing. The space between any two items or item and container edge is the same.

For example, if three items share a row:

```css
.container { display: flex; justify-content: space-between; }
```

puts one at start, one at end, and one exactly in the middle of the leftover space.
Using `space-around` would give a half-gap at each edge, while `space-evenly` gives equal gaps everywhere. MDN describes `space-between` as distributing items so each pair has the same gap and the first/last align to edges.

# 25. `align-items` vs `align-content`

Both properties deal with the *cross-axis* alignment in a flex container, but at different levels. `align-items` aligns **flex items** *within a single line*. For example, `align-items: center` vertically centers all items in the flex line. This works even if there is only one line.

`align-content`, on the other hand, only affects multi-line (wrapped) flex containers. It aligns the *flex lines* relative to each other. For example, `align-content: space-between` will spread out the rows, the first row at the top and last at the bottom (if the container is taller than the total items). It has no effect if there is only one line of items. In short, use `align-items` to align items in each row/column, and `align-content` to align rows when you have wrapping and extra space.

# 26. CSS `flex` Shorthand (`auto`, `none`, `1`)

The `flex` shorthand sets `flex-grow`, `flex-shrink`, and `flex-basis`. Common values are:

* `flex: none` is equivalent to `flex: 0 0 auto`. It means the item will *not* grow or shrink and will size to its content/basis.
* `flex: auto` expands to `1 1 auto`. The item is sized by its `width`/`height` but can grow (`1`) to fill space or shrink (`1`) if needed.
* `flex: 1` is shorthand for `1 1 0%` (grow and shrink, initial basis 0). This makes items stretch equally to fill available space.

For example, `.item { flex: 1; }` ensures that all items grow equally. The MDN documentation clarifies these defaults: “`auto` expands to `flex: 1 1 auto`” so the item can flex, while “`none` equals `0 0 auto`” so it behaves like a static-size element.

# 27. `display: none` vs `visibility: hidden`

`display: none` **removes** the element from the document flow entirely: it takes up no space and is not rendered or accessible (content is also hidden from screen readers). In contrast, `visibility: hidden` hides the element visually but it still occupies its layout space (and its place in the tab order is typically removed). Use `display: none` when you want the element gone (no space), and `visibility: hidden` when you want to hide it but preserve layout space. Be cautious: hiding critical content with CSS can impact accessibility – ensure it’s appropriate for the user experience (e.g. hidden submenus might need `aria-expanded` control).

# 28. `flex-wrap` Property

The `flex-wrap` property controls whether flex items stay on one line or wrap onto multiple lines. Its values are:

* `nowrap` (default): all flex items are forced into a single line, possibly overflowing the container.
* `wrap`: items wrap onto new lines from top to bottom (or left to right for vertical flex).
* `wrap-reverse`: items wrap in reverse order (bottom to top).

For example:

```css
.container {
  display: flex;
  flex-wrap: wrap;
}
```

allows child items to break into multiple lines if needed. The MDN spec explains that `flex-wrap: wrap` lets items break into multiple lines and determines how lines stack. The shorthand `flex-flow` can set direction and wrap together (e.g. `flex-flow: row wrap`). Using `flex-wrap: wrap` is common for responsive flex layouts where items should flow to the next row instead of squishing.

# 29. Flexbox vs Grid (When to Use Each)

Flexbox and Grid are complementary. **Flexbox** is one-dimensional: it lays out items in a single row *or* column. It’s ideal for components like navbars, toolbars, or any layout that needs to align items along one axis. **Grid** is two-dimensional: it handles both rows *and* columns, making it suitable for overall page layouts or complex modules where you need control over both axes. For example, for a full page layout with header, sidebar, main, and footer areas, Grid can define rows and columns explicitly.

MDN (via CSS-Tricks) notes: *“Flexbox layout is most appropriate to components ... and small-scale layouts, whereas Grid is intended for larger-scale layout”*. In practice, use Flexbox when you need straightforward alignment/distribution along one axis, and use Grid when you need precise control of rows and columns together. Both can be used together: e.g., Grid for the page, and Flexbox for elements within grid cells.

# 30. CSS Media Queries (Responsive Design)

Media queries let CSS adapt to different devices or conditions. They use `@media` rules with media types (screen, print) and features (width, orientation, etc.). For example:

```css
/* Apply styles only on small screens */
@media (max-width: 600px) {
  .sidebar { display: none; }
}
```

This hides `.sidebar` on viewports 600px wide or less. MDN explains that media queries test features like viewport width, resolution, orientation, etc. to conditionally apply styles. You can chain features with `and` or comma-separate queries. This is the basis of responsive design: adjusting layouts for mobile vs desktop.

Modern media features include `prefers-color-scheme` (dark mode), `prefers-reduced-motion`, and many others. By using media queries, you ensure your design responds to the user’s device and preferences, e.g. stacking a multi-column grid into one column on narrow screens, or increasing font size for high-resolution displays.

**Sources:** Authoritative documentation from MDN and CSS specifications for each topic.
